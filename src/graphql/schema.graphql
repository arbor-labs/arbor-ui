type Account {
	address: EthereumAddress!
	avatarUrl: String
	collaboratedProjects: [Project!]!
	createdAt: DateTime!
	createdProjects: [Project!]!
	displayName: String
	id: ID!
	onboardingSignature: EthereumSignature!
	stems: [Stem!]!
	updatedAt: DateTime!
	voterIdentities: [SemaphoreIdentity!]!
}

input CreateAccountInput {
	address: EthereumAddress!
	signature: EthereumSignature!
}

input CreateProjectInput {
	bpm: Int!
	createdBy: EthereumAddress!
	description: String!
	name: String!
	tags: [String!] = []
	trackLimit: Int!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

"""
A string whose value conforms to the standard Ethereum address format as specified in EIP-150 Revision (212): http://gavwood.com/paper.pdf.
"""
scalar EthereumAddress @specifiedBy(url: "http://gavwood.com/paper.pdf")

"""
A string whose value conforms to the standard Ethereum signature format as specified in EIP-150 Revision (212): http://gavwood.com/paper.pdf
"""
scalar EthereumSignature @specifiedBy(url: "http://gavwood.com/paper.pdf")

type Mutation {
	createAccount(createAccountInput: CreateAccountInput!): Account!
	createProject(createProjectInput: CreateProjectInput!): Project!
	findOrCreateAccount(createAccountInput: CreateAccountInput!): Account!
}

type PaginatedAccounts {
	items: [Account!]
	meta: PaginationMeta!
}

type PaginatedProjects {
	items: [Project!]
	meta: PaginationMeta!
}

type PaginationMeta {
	currentPage: Int!
	itemCount: Int!
	itemType: String!
	itemsPerPage: Int!
	totalItems: Int!
	totalPages: Int!
}

type PinataCIDResponse {
	contentType: PinataContentType
	data: PinataData
}

"""
A valid content type supported by both Pinata and Arbor, usually NFT metadata and WAV audio files: https://docs.pinata.cloud/sdk/gateways/get#returns.
"""
scalar PinataContentType @specifiedBy(url: "https://docs.pinata.cloud/sdk/gateways/get#returns")

"""
Custom scalar type for Pinata data that can JSON or a base64 encoded string of a Blob.
"""
scalar PinataData

type Project {
	bpm: Int!
	collaborators: [Account!]
	createdAt: DateTime!
	createdBy: Account!
	description: String!
	id: ID!
	name: String!
	queue: ProjectQueue!
	stems: [Stem!]
	tags: [String!]!
	trackLimit: Int!
	updatedAt: DateTime!
	votingGroup: VotingGroup!
}

type ProjectQueue {
	createdAt: DateTime!
	id: ID!
	stems: [QueuedStem!]!
	updatedAt: DateTime!
}

type Query {
	account(address: EthereumAddress!): Account
	accounts(sort: SortInput): PaginatedAccounts!
	getFile(cid: String!): PinataCIDResponse!
	project(id: String!): Project!
	projects(sort: SortInput): PaginatedProjects!
}

type QueuedStem {
	createdAt: DateTime!
	id: ID!
	queue: ProjectQueue!
	stem: Stem!
	updatedAt: DateTime!
	votes: Int!
}

type SemaphoreIdentity {
	account: Account!
	commitment: String!
	createdAt: DateTime!
	group: VotingGroup!
	id: ID!
	nullifier: String!
	trapdoor: String!
	updatedAt: DateTime!
}

input SortInput {
	asc: Boolean!
	key: String!
}

type Stem {
	audioCID: String!
	createdAt: DateTime!
	createdBy: Account!
	filename: String!
	filesize: Int!
	filetype: String!
	id: ID!
	metadataCID: String!
	name: String!
	projectsAddedTo: [Project!]!
	type: String!
	updatedAt: DateTime!
}

type VotingGroup {
	createdAt: DateTime!
	id: ID!
	members: [SemaphoreIdentity!]!
	updatedAt: DateTime!
}
